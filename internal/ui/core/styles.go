// Package core provides the foundational elements for UI components.
// This file defines standard layout constants, UI messages, and the Styles struct
// which holds all lipgloss styles used in the application. It also provides
// functions to build and access these styles based on the current theme.
//
// Usage:
// - Access layout constants (e.g., `core.PanelWidth`, `core.ListHeight`).
// - Access UI messages (e.g., `core.ListEmptyMsg`).
// - Get the current styles using `core.CurrentStyles()`.
// - The styles are built based on the theme set via `core.SetTheme()`.
//
// Example:
//
// import (
//
//	"github.com/charmbracelet/lipgloss"
//	"a-la-carte/internal/ui/core"
//
// )
//
//	func MyComponentView(model MyModel) string {
//	  styles := core.CurrentStyles()
//	  title := styles.TitleStyle.Render("My Awesome Component")
//	  listItem := styles.ItemStyle.Render("- An item")
//	  return lipgloss.JoinVertical(lipgloss.Left, title, listItem)
//	}
package core

import (
	"github.com/charmbracelet/lipgloss"
)

// Layout constants for consistent sizing across components.
// These define standard dimensions for various UI elements like panels and lists.
const (
	// PanelWidth is the standard width for main UI panels.
	PanelWidth = 120
	// ListHeight is the standard height for list views within panels.
	ListHeight = 12
	// DetailHeight is the standard height for detail views.
	DetailHeight = 7
	// DetailHeightExpand is the expanded height for detail views, used when more content is shown.
	DetailHeightExpand = 16

	// BorderWidth defines the thickness of borders or padding around main panels.
	BorderWidth = 4
	// ListItemPadding is the horizontal padding for list items, often used for icons or spacing.
	ListItemPadding = 8
	// DetailsPanelWrapPadding is the width to subtract from PanelWidth for text wrapping in details panels.
	DetailsPanelWrapPadding = 10

	// LeftPaneWidth is the calculated width of the left (often unselected) pane in a split view.
	LeftPaneWidth = (PanelWidth - BorderWidth) / 2
	// RightPaneWidth is the calculated width of the right (often selected) pane in a split view.
	RightPaneWidth = (PanelWidth - BorderWidth) - LeftPaneWidth

	// SplitPaneRatio is the default ratio for splitting horizontal space between left and right panes.
	SplitPaneRatio = 0.5
	// VerticalRatio is the default ratio for splitting vertical space, e.g., between a list and details.
	VerticalRatio = 0.7
)

// Message constants for standard UI messages displayed to the user.
const (
	// ListEmptyMsg is the message shown when a list component has no items to display.
	ListEmptyMsg = "No more software. Press / to edit filter."
	// SelectedEmptyMsg is the message shown when a list of selected items is empty.
	SelectedEmptyMsg = "No software selected."
)

// Detail view header and label constants used for consistent labeling in detail panels.
const (
	DetailsHeader = "Details"
	NameLabel     = "Name: "
	KeyLabel      = "Key: "
	DescLabel     = "Desc: "
	BinLabel      = "Bin: "
	BrewLabel     = "Brew: "
	AptLabel      = "Apt: "
	PacmanLabel   = "Pacman: "
	DocsLabel     = "Docs: "
	GithubLabel   = "GitHub: "
	HomeLabel     = "Home: "
)

// LayoutMetrics provides computed layout values based on the base constants.
// This struct can be used to pass around common layout dimensions.
// Currently, DefaultLayoutMetrics is provided, but this struct could be expanded
// to allow dynamic layout calculations if needed.
type LayoutMetrics struct {
	// Base values
	PanelWidth         int
	ListHeight         int
	DetailHeight       int
	DetailHeightExpand int
	BorderWidth        int

	// Pane widths
	LeftPaneWidth  int
	RightPaneWidth int

	// Total widths including borders
	TotalWidth  int
	TotalHeight int
}

// DefaultLayoutMetrics returns a LayoutMetrics struct populated with the default constant values.
func DefaultLayoutMetrics() LayoutMetrics {
	return LayoutMetrics{
		PanelWidth:         PanelWidth,
		ListHeight:         ListHeight,
		DetailHeight:       DetailHeight,
		DetailHeightExpand: DetailHeightExpand,
		BorderWidth:        BorderWidth,
		LeftPaneWidth:      LeftPaneWidth,
		RightPaneWidth:     RightPaneWidth,
		TotalWidth:         PanelWidth,                              // Assuming PanelWidth is the outermost width
		TotalHeight:        ListHeight + DetailHeight + BorderWidth, // Example calculation
	}
}

// Styles holds the shared lipgloss.Style definitions for the application.
// Each field represents a style for a specific UI element or text type.
// These styles are generated by BuildStyles() based on the CurrentTheme().
type Styles struct {
	// Text styles
	TitleStyle        lipgloss.Style // Style for main titles.
	TitleHeaderStyle  lipgloss.Style // Style for titles within headers or specific sections.
	SubtitleStyle     lipgloss.Style // Style for subtitles or secondary headings.
	ItemStyle         lipgloss.Style // Default style for items in a list.
	SelectedItemStyle lipgloss.Style // Style for selected items in a list (e.g., when navigating with arrow keys but pane not focused).
	ActiveItemStyle   lipgloss.Style // Style for the currently active/focused item in a list (e.g., when pane is focused).
	DescriptionStyle  lipgloss.Style // Style for descriptive text, often muted.
	FooterStyle       lipgloss.Style // Style for footer text, typically small and italicized.
	ErrorStyle        lipgloss.Style // Style for error messages.

	// UI element styles
	BorderStyle    lipgloss.Style // Default style for borders around panels and elements.
	HighlightStyle lipgloss.Style // Style for highlighting text or elements.
	DimStyle       lipgloss.Style // Style for dimming text or elements, making them less prominent.

	// Panel styles
	ListPanel      lipgloss.Style // Style for panels containing lists.
	DetailPanel    lipgloss.Style // Style for panels displaying details.
	IndicatorStyle lipgloss.Style // Style for scrollbar indicators or similar visual cues.

	// Additional styles for specific component parts
	HeaderStyle            lipgloss.Style // General style for headers within components.
	DetailKey              lipgloss.Style // Style for keys (labels) in a key-value detail display.
	DetailValueStyle       lipgloss.Style // Style for values in a key-value detail display.
	DetailValueActiveStyle lipgloss.Style // Style for values in a key-value detail display when the item is active/focused.
}

// BuildStyles creates and returns a new Styles instance.
// It uses the CurrentTheme() to configure the colors and attributes of each style.
// This function is called to initialize or update the application's styles when the theme changes.
func BuildStyles() Styles {
	theme := CurrentTheme()

	return Styles{
		TitleStyle: lipgloss.NewStyle().
			Foreground(theme.Primary()).
			Bold(true),

		TitleHeaderStyle: lipgloss.NewStyle().
			Foreground(theme.Primary()).
			Background(theme.Background()). // Ensure header titles have a defined background
			Bold(true).
			Padding(0, 1),

		SubtitleStyle: lipgloss.NewStyle().
			Foreground(theme.Secondary()).
			Bold(true),

		ItemStyle: lipgloss.NewStyle().
			Foreground(theme.Text()),

		SelectedItemStyle: lipgloss.NewStyle(). // Style for when an item is selected but not necessarily active/focused
							Foreground(theme.TextActive()).
							Background(theme.BackgroundActive()),

		ActiveItemStyle: lipgloss.NewStyle(). // Style for when an item is truly active (e.g. cursor on it and pane focused)
							Foreground(theme.Accent()).
							Bold(true),

		DescriptionStyle: lipgloss.NewStyle().
			Foreground(theme.TextMuted()),

		FooterStyle: lipgloss.NewStyle().
			Foreground(theme.TextMuted()).
			Italic(true),

		ErrorStyle: lipgloss.NewStyle().
			Foreground(lipgloss.Color("#f00")). // Standard red for errors
			Bold(true),

		BorderStyle: lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(theme.Border()),

		HighlightStyle: lipgloss.NewStyle().
			Foreground(theme.Accent()).
			Bold(true),

		DimStyle: lipgloss.NewStyle().
			Foreground(theme.TextMuted()),

		HeaderStyle: lipgloss.NewStyle().
			Foreground(theme.Primary()).
			Bold(true),

		DetailKey: lipgloss.NewStyle().
			Foreground(theme.Secondary()).
			Bold(true),

		DetailValueStyle: lipgloss.NewStyle().
			Foreground(theme.Text()),

		DetailValueActiveStyle: lipgloss.NewStyle().
			Foreground(theme.TextActive()), // Consider if this should be different from DetailValueStyle

		ListPanel: lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(theme.Border()).
			Padding(0, 1).
			Margin(0, 0),

		DetailPanel: lipgloss.NewStyle().
			Border(lipgloss.RoundedBorder()).
			BorderForeground(theme.Border()).
			Padding(1, 2).
			Margin(0, 0),

		IndicatorStyle: lipgloss.NewStyle().
			Background(theme.Background()). // Ensure indicator background matches panel
			Foreground(theme.TextMuted()),  // Default to muted/unfocused color
	}
}

// currentStyles holds the globally accessible current styles.
// It is cached to avoid rebuilding styles on every access.
var currentStyles Styles
var stylesInitialized bool // Flag to track initialization

// SetStyles updates the global currentStyles.
// This can be used if styles need to be changed programmatically after initial build,
// though typically styles are rebuilt when the theme changes.
func SetStyles(styles *Styles) {
	currentStyles = *styles
}

// CurrentStyles returns the current application styles.
// It employs lazy initialization: if currentStyles hasn't been populated (e.g., at startup),
// it calls BuildStyles() to create them based on the CurrentTheme().
func CurrentStyles() Styles {
	if !stylesInitialized {
		currentStyles = BuildStyles()
		stylesInitialized = true
	}
	return currentStyles
}

// IndicatorStyle returns the style for scroll indicators (e.g., in lists or scrollable views).
// The style adapts based on whether the associated component is focused.
// - When `focused` is true, the indicator is bold and uses the theme's active accent color.
// - When `focused` is false, it uses a muted text color.
// The base style (including background) is taken from `CurrentStyles().IndicatorStyle`.
func IndicatorStyle(focused bool) lipgloss.Style {
	style := CurrentStyles().IndicatorStyle // Start with the base indicator style

	if focused {
		return style.Foreground(CurrentTheme().AccentActive()).Bold(true)
	}
	// For unfocused, the default foreground (TextMuted) from BuildStyles is already set.
	// No change needed unless a different unfocused style is desired.
	return style
}

// init ensures that a default theme is set and initial styles are built when the package is loaded.
// This prevents errors if CurrentStyles() or CurrentTheme() are accessed before explicit setup.
func init() {
	// Ensure a default theme is available before building styles.
	if CurrentTheme() == nil {
		SetTheme(DefaultTheme{})
	}

	// Initialize styles with the current (default or pre-set) theme.
	currentStyles = BuildStyles()
	stylesInitialized = true // Mark styles as initialized
}
